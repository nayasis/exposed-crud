package com.dshatz.exposed_crud.typed

import org.jetbrains.exposed.dao.id.EntityID
import org.jetbrains.exposed.dao.id.IdTable
import org.jetbrains.exposed.dao.id.IntIdTable
import org.jetbrains.exposed.dao.id.LongIdTable
import org.jetbrains.exposed.dao.id.UIntIdTable
import org.jetbrains.exposed.dao.id.ULongIdTable
import org.jetbrains.exposed.dao.id.UUIDTable
import org.jetbrains.exposed.sql.ColumnSet
import org.jetbrains.exposed.sql.Op
import org.jetbrains.exposed.sql.Query
import org.jetbrains.exposed.sql.ResultRow
import org.jetbrains.exposed.sql.SizedIterable
import org.jetbrains.exposed.sql.SqlExpressionBuilder
import org.jetbrains.exposed.sql.SqlExpressionBuilder.eq
import org.jetbrains.exposed.sql.deleteWhere
import org.jetbrains.exposed.sql.insert
import org.jetbrains.exposed.sql.insertAndGetId
import org.jetbrains.exposed.sql.insertReturning
import org.jetbrains.exposed.sql.mapLazy
import org.jetbrains.exposed.sql.selectAll
import org.jetbrains.exposed.sql.statements.InsertStatement
import org.jetbrains.exposed.sql.update

data class CrudRepository<T, ID : Any, E : Any>(val table: T, val related: List<ColumnSet> = emptyList()) where T: IdTable<ID>, T: IEntityTable<E, ID> {

    private fun selectWithJoins(): Query {
        return if (related.isEmpty()) {
            table.selectAll()
        } else {
            var source = table.leftJoin(related.first())
            related.drop(1).forEach {
                source = source.leftJoin(it)
            }
            source.selectAll()
        }
    }

    /**
     * Lazy-select all entities.
     *
     * If this repo has related entities defined using [withRelated], corresponding Reference properties will be populated.
     */
    fun selectAllLazy(): SizedIterable<E> {
        return selectWithJoins().mapLazy(::toEntity)
    }

    /**
     * Select all entities. Use with caution.
     *
     * If this repo has related entities defined using [withRelated], corresponding Reference properties will be populated.
     */
    fun selectAll(): List<E> {
        return selectWithJoins().map(::toEntity)
    }

    /**
     * Perform an `INSERT`, ignoring the value of auto-incrementing columns.
     * Use [createReturning] to retrieve the ID generated by the database.
     */
    fun create(data: E): InsertStatement<Number> {
        return table.insert {
            table.writeExceptAutoIncrementing(it, data)
        }
    }

    /**
     * Perform an `INSERT` on all columns except ones marked as auto-incrementing.
     * @return inserted entity.
     */
    fun createReturning(data: E): E {
        return when (table) {
            is IntIdTable, is UIntIdTable, is LongIdTable, is ULongIdTable, is UUIDTable -> {
                val id = table.insertAndGetId {
                    table.writeExceptAutoIncrementing(it, data)
                }
                @Suppress("UNCHECKED_CAST")
                table.setId(data, id.value as ID)
            } else -> {
                table.insert {
                    table.writeExceptAutoIncrementing(it, data)
                }
                val pk = table.makePK(data).value
                findById(pk) ?: error("failed to retrieve inserted entity with PK: $pk")
            }
        }
    }

    /**
     * Perform an `INSERT` on all columns, including columns marked as auto-incrementing.
     */
    fun insert(data: E): InsertStatement<Number> {
        return table.insert {
            table.write(it, data)
        }
    }

    /**
     * Perform an `INSERT` on all columns including columns marked as auto-incrementing.
     * @return inserted entity.
     */
    fun insertReturning(data: E): E {
        return table.insertReturning {
            table.write(it, data)
        }.first().let(::toEntity)
    }

    @Deprecated("Needs re-thinking")
    fun update(where: SqlExpressionBuilder.() -> Op<Boolean>, data: E) {
        table.update(where) {
            table.writeExceptAutoIncrementing(it, data)
        }
    }

    /**
     * Perform an `UPDATE` based on the primary key.
     */
    fun update(data: E) {
        with (table) {
            update({
                table.id eq table.makePK(data)
            }) {
                table.write(it, data)
            }
        }
    }

    /**
     * Start a `SELECT`.
     */
    fun select(): TypedSelect<T, E, ID> {
        return TypedSelect(table, selectWithJoins())
    }

    /**
     * Creates a new CrudRepository that will include given related entities in queries.
     *
     * When doing a select, corresponding @References and @BackReferences annotated columns will be populated if present.
     * Example:
     *
     * ```kotlin
     * data class Movie(
     *  val title: String,
     *
     *  @ForeignKey(Director::class)
     *  val directorId: Long,
     *
     *  @References(Director::class, "directorId")
     *  val director: Director? = null
     * )
     * ```
     * Assuming we have inserted one director and one movie having `Movie.directorId == Director.id`,
     *
     * ```kotlin
     * val movie = Movie::class.repo.withRelated(Director::class).selectAll().first()
     * assertNotNull(movie?.director)
     * assertIs<Director>(movie?.director)
     * // Movie.director is of type Director.
     * ```
     *
     */
    fun withRelated(table: ColumnSet) = copy(related = related + table)

    fun withRelated(vararg tables: ColumnSet) = copy(related = related + tables)

    fun findById(id: ID): E? {
        val eid = EntityID(id, table)
        return selectWithJoins().where({
            table.id eq eid
        }).limit(1).firstOrNull()?.let(::toEntity)
    }

    private fun toEntity(resultRow: ResultRow): E {
        return table.toEntity(resultRow, related)
    }

    fun findOne(where: SqlExpressionBuilder.() -> Op<Boolean>): E? {
        return select().where(where).limit(1).firstOrNull()
    }

    /**
     * Deletes given entity by primary key.
     */
    fun delete(data: E, limit: Int? = null): Int {
        return with (table) {
            deleteWhere(limit = limit) {
                table.id eq table.makePK(data)
            }
        }
    }
}