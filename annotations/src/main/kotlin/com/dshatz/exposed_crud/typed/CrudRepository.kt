package com.dshatz.exposed_crud.typed

import org.jetbrains.exposed.v1.core.dao.id.EntityID
import org.jetbrains.exposed.v1.core.dao.id.IdTable
import org.jetbrains.exposed.v1.core.dao.id.IntIdTable
import org.jetbrains.exposed.v1.core.dao.id.LongIdTable
import org.jetbrains.exposed.v1.core.dao.id.UIntIdTable
import org.jetbrains.exposed.v1.core.dao.id.ULongIdTable
import org.jetbrains.exposed.v1.core.dao.id.UUIDTable
import org.jetbrains.exposed.v1.core.*
import org.jetbrains.exposed.v1.core.statements.InsertStatement
import org.jetbrains.exposed.v1.jdbc.*

data class CrudRepository<T, ID : Any, E : Any>(val table: T, val related: List<ColumnSet> = emptyList()) where T: IdTable<ID>, T: IEntityTable<E, ID> {

    private fun selectWithJoins(): Query {
        return if (related.isEmpty()) {
            table.selectAll()
        } else {
            var source = table.leftJoin(related.first())
            related.drop(1).forEach {
                source = source.leftJoin(it)
            }
            source.selectAll()
        }
    }

    /**
     * Lazy-select all entities.
     *
     * If this repo has related entities defined using [withRelated], corresponding Reference properties will be populated.
     */
    fun selectAllLazy(): SizedIterable<E> {
        return selectWithJoins().mapLazy(::toEntity)
    }

    /**
     * Select all entities. Use with caution.
     *
     * If this repo has related entities defined using [withRelated], corresponding Reference properties will be populated.
     */
    fun selectAll(): List<E> {
        return selectWithJoins().map(::toEntity)
    }

    /**
     * Perform an `INSERT`, ignoring the value of auto-incrementing columns.
     * Use [createReturning] to retrieve the ID generated by the database.
     */
    fun create(data: E): InsertStatement<Number> {
        return table.insert {
            table.writeExceptAutoIncrementing(it, data)
        }
    }

    /**
     * Perform an `INSERT` on all columns except ones marked as auto-incrementing.
     * @return inserted entity.
     */
    fun createReturning(data: E): E {
        return when (table) {
            is IntIdTable, is UIntIdTable, is LongIdTable, is ULongIdTable, is UUIDTable -> {
                val id = table.insertAndGetId {
                    table.writeExceptAutoIncrementing(it, data)
                }
                @Suppress("UNCHECKED_CAST")
                table.setId(data, id.value as ID)
            } else -> {
                table.insert {
                    table.writeExceptAutoIncrementing(it, data)
                }
                val pk = table.makePK(data).value
                findById(pk) ?: error("failed to retrieve inserted entity with PK: $pk")
            }
        }
    }

    /**
     * Perform an `INSERT` on all columns, including columns marked as auto-incrementing.
     */
    fun insert(data: E): InsertStatement<Number> {
        return table.insert {
            table.write(it, data)
        }
    }

    /**
     * Perform an `INSERT` on all columns including columns marked as auto-incrementing.
     * @return inserted entity.
     */
    fun insertReturning(data: E): E {
        return table.insertReturning {
            table.write(it, data)
        }.first().let(::toEntity)
    }

    @Deprecated("Needs re-thinking")
    fun update(where: () -> Op<Boolean>, data: E) {
        table.update(where) {
            table.writeExceptAutoIncrementing(it, data)
        }
    }

    /**
     * Perform an `UPDATE` based on the primary key.
     */
    fun update(data: E) {
        with (table) {
            update({
                table.id eq table.makePK(data)
            }) {
                table.write(it, data)
            }
        }
    }

    /**
     * Start a `SELECT`.
     */
    fun select(): TypedSelect<T, E, ID> {
        return TypedSelect(table, selectWithJoins())
    }

    /**
     * Creates a new CrudRepository that will include given related entities in queries.
     *
     * When doing a select, corresponding @References and @BackReferences annotated columns will be populated if present.
     * Example:
     *
     * ```kotlin
     * data class Movie(
     *  val title: String,
     *
     *  @ForeignKey(Director::class)
     *  val directorId: Long,
     *
     *  @References(Director::class, "directorId")
     *  val director: Director? = null
     * )
     * ```
     * Assuming we have inserted one director and one movie having `Movie.directorId == Director.id`,
     *
     * ```kotlin
     * val movie = Movie::class.repo.withRelated(Director::class).selectAll().first()
     * assertNotNull(movie?.director)
     * assertIs<Director>(movie?.director)
     * // Movie.director is of type Director.
     * ```
     *
     */
    fun withRelated(table: ColumnSet) = copy(related = related + table)

    fun withRelated(vararg tables: ColumnSet) = copy(related = related + tables)

    fun findById(id: ID): E? {
        val eid = EntityID(id, table)
        return selectWithJoins().where({
            table.id eq eid
        }).limit(1).firstOrNull()?.let(::toEntity)
    }

    private fun toEntity(resultRow: ResultRow): E {
        return table.toEntity(resultRow, related)
    }

    fun findOne(where: () -> Op<Boolean>): E? {
        return select().where(where).limit(1).firstOrNull()
    }

    /**
     * Deletes given entity by primary key.
     */
    fun delete(data: E, limit: Int? = null): Int {
        return with (table) {
            deleteWhere(limit = limit) {
                table.id eq table.makePK(data)
            }
        }
    }
}